<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Nearly-Optimal Mergesorts: Fast, Practical Sorting Methods That Optimally Adapt to Existing Runs</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/fonts/pagella/stylesheet.css" type="text/css" charset="utf-8" />
  <link rel="stylesheet" href="/fonts/epigrafica/stylesheet.css" type="text/css" charset="utf-8" />
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://www.wild-inter.net/publications/munro-wild-2018">
  <link rel="alternate" type="application/rss+xml" title="Sebastian Wild's Site" href="https://www.wild-inter.net/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Sebastian</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#46433A" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#46433A" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#46433A" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/research">Research</a>
          
        
          
          <a class="page-link" href="/teaching/">Teaching</a>
          
        
          
          <a class="page-link" href="/posts/">Blog</a>
          
        
          
          <a class="page-link" href="/about">About</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post">
	<div class="post-back">
		<small>
			<a href="/publications/">⬑ All Publications</a>
		</small>
	</div>

	<header class="publication-header">
		<h1 class="publication-title"><p>Nearly-Optimal Mergesorts: Fast, Practical Sorting Methods That Optimally Adapt to Existing Runs</p>
</h1>

		<div class="publication-meta">
			<p style="text-align:left">
				<small>
				May 2018
				<span style="padding-left:1em;">
					<small>(Written: May 2018)</small>
				</span>
				</small>
			</p>
			<p>
				
				<p><a href="https://cs.uwaterloo.ca/~imunro/">J. Ian Munro</a> and Sebastian Wild:</p>

			</p>
			<p>
				<p><a href="http://algo2018.hiit.fi/esa/">European Symposium on Algorithms 2018</a><br /> <small>in Y. Azar and H. Bast and G. Herman (Eds.): ESA 2018, LIPIcs 112, Dagstuhl, 2018, 63:1-63:16</small></p>

			</p>
			<p>
				
				
				
					|&nbsp;<a href="munro-wild-2018.pdf" title="munro-wild-2018.pdf (preprint)">pdf</a>
				
				
					|&nbsp;<a href="https://dx.doi.org/10.4230/LIPIcs.ESA.2018.63" title="10.4230/LIPIcs.ESA.2018.63">doi</a>
				
				
				
				
				
					|&nbsp;<a href="https://arxiv.org/abs/1805.04154" title="1805.04154">arxiv</a>
				
				
					|&nbsp;<a href="https://speakerdeck.com/sebawild/nearly-optimal-mergesort">slides</a>
				
				
					|&nbsp;<a href="https://github.com/sebawild/nearly-optimal-mergesort-code">github</a>
				
				
				|
			</p>

			
			<p>| <a href="/publications/html/munro-wild-2018.pdf.html"><em>read here</em></a> |</p>
			

		</div>

	</header>

	<div class="publication-content">
		
<script type="text/x-mathjax-config">
	var font = "Neo-Euler";
	MathJax.Hub.Config({
		tex2jax: {
			inlineMath: [['$','$']],
			displayMath: [['\\[','\\]']],
			processEscapes: true,
		},
		"SVG":{ 
			font:font
		},
		"HTML-CSS": {
			webFont: font,
			imageFont: font,
			preferredFont: font,
			availableFonts: [],
			scale: 85,
			mtextFontInherit: true
		}
	});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p>Mergesort can make use of existing order in the input by
picking up <em>existing runs</em>, i.e., segments that are already sorted.
Since the lengths of these runs can be arbitrary,
simply merging them as they arrive can be wasteful—merging can
degenerate to inserting a single element into a long run.</p>

<p>In this paper, we show that we can find an <em>optimal</em> merging order (up to lower order
terms of costs) with negligible overhead and thereby get the <em>same worst-case guarantee</em>
as for classic mergesort (up to lower order terms),
while exploiting existing runs if present.
Our two new mergesort variants,
<a href="#peeksort"><em>peeksort</em></a> and <a href="#powersort"><em>powersort</em></a>, are simple, stable,
optimally adaptive and fast in practice (never slower
than classic mergesort and <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a>,
but significantly faster on certain inputs, see <a href="html/munro-wild-2018.pdf.html#pfa">§4 of the paper</a>).</p>

<h2 id="natural-mergesort">Natural Mergesort</h2>

<p>The simplest version of run-adaptive mergesort starts with
<a href="https://algs4.cs.princeton.edu/22mergesort/MergeBU.java.html">bottom-up mergesort</a>,
but instead of blindly treating every element as a minimal run of length 1,
we detect existing sorted segments.
Knuth presents a clever implementation of this strategy under the name <a href="https://en.wikipedia.org/wiki/Merge_sort#Natural_merge_sort"><em>“natural mergesort”</em></a>
(Algorithm 5.2.4–N in <a href="https://www-cs-faculty.stanford.edu/~knuth/taocp.html#vol3">TAOCP</a>).
It detects runs while merging them and so avoids to ever keep track of all the
run lengths.</p>

<p>This can save a lot of work if long runs are present,
but the merging order can be suboptimal (see below) and the merging procedure itself
uses additional comparisons to re-detect the run boundaries in each pass.</p>

<h3 id="a-bad-case-for-natural-mergesort">A bad case for natural mergesort</h3>

<p>An example where merging left to right is wasteful is the following class of inputs.
Suppose $n$ is a power of two and the
the runs lengths are $n/2, 1, 1, 2, 4, 8, \ldots, n/4$.
For $n=64$, the runs look like the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|================================|=|=|==|====|========|================|
</code></pre></div></div>

<p>There are $1+\lg n$ runs, so bottom-up mergesort would do $\lceil\lg\lg n\rceil$ passes,
in each pass touching all $n$ elements for a total cost of $n \lceil\lg\lg n\rceil$.
However, by iteratively merging the shortest runs, the average number of merges
one element participates in is $2$, so we can merge these runs with total cost of $2n$.</p>

<h2 id="mergesort-and-optimal-binary-search-trees">Mergesort and optimal binary search trees</h2>

<p>The problem of determining the best order for merges turns out to be equivalent
to well-studied coding problems.
Indeed, if we take the cost of one merge to be the output size (<em>“merge costs” model</em>),
the total merge cost is exactly the total weighted code length of a corresponding
prefix-free code, where the symbols are the runs and their weights are the
lengths of the runs.</p>

<p>An obvious choice is thus to simulate the <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman code</a>
(iteratively merging shortest runs, as in the above example),
but in general, that does not lead to a <em>stable</em> sort
since it might involve merging nonadjacent runs.
Optimal stable options correspond to <a href="https://en.wikipedia.org/wiki/Huffman_coding#Optimal_alphabetic_binary_trees_(Hu%E2%80%93Tucker_coding)">alphabetic a.k.a. Hu-Tucker codes</a>, or equivalently, <a href="https://en.wikipedia.org/wiki/Optimal_binary_search_tree">optimal binary search trees</a>.</p>

<p>While these approaches principally work, the overhead for finding the merging order
easily exceeds the benefit gained.
Recall that even in the specifically crafted example above,
the improvement was to replace a multiplicative $\lg\lg n$ by $2$,
which, in this universe, is a speedup by a factor of 2–3 really.
So if such an optimized mergesort is to result in an overall faster sorting method,
the merging order must be found with negligible overhead.</p>

<h2 id="nearly-optimal-mergesort">Nearly-optimal mergesort</h2>

<p>We therefore rely on methods to compute
<em>nearly-optimal binary search trees</em>, simple linear-time methods that compute
search trees that are within a small additive constant of the entropy
(and thus the optimal tree).
They consist in greedily choosing the root so as to balance the topmost split
as much as possible, and recursively build the subtrees.
There are several variants that differ in the details.</p>

<ul>
  <li><strong>Method 1</strong>, a.k.a. the <em>weight-balancing rule,</em> is described in one of <a href="https://people.mpi-inf.mpg.de/~mehlhorn/">Kurt Mehlhorn</a>’s
earliest papers ever:
<a href="http://www.mpi-sb.mpg.de/~mehlhorn/ftp/mehlhorn3.pdf"><em>Nearly Optimal Binary Search Trees</em></a>.
It uses the most straight-forward way to recurse.</li>
  <li><strong>Method 2</strong>, a.k.a. the <em>bisection rule,</em> was proposed by Kurt Mehlhorn
shortly after that in
<a href="http://www.mpi-sb.mpg.de/~mehlhorn/ftp/mehlhorn10.pdf"><em>A Best Possible Bounds for the Weighted Path Length of Binary Search Trees</em></a>.
It continues halving the original interval irrespective of the actual split at the root.</li>
</ul>

<p><a href="html/munro-wild-2018.pdf.html#pf5">Figure 1 in the paper</a>
illustrates the two methods.</p>

<h3 id="peeksort">Peeksort</h3>
<p>Method 1 leads to <em>peeksort:</em> we simulate cutting the probability in half
by <em>finding the run boundary closest to the middle of the array.</em>
We can do that by simply scanning left and right from the middle, until
we find the first out-of-order pair.
With two additional indices passed down to the recursive calls, we can avoid
every scanning the same run twice in this “peeking-at-the-middle” process.</p>

<p>The awesome property of peeksort is that we do <em>not</em> have to detect the runs
<em>up front;</em> we can delay this step until we really need to know a boundary.
In case the input does not contain long runs, we do not much more work
than standard top-down mergesort.</p>

<h3 id="powersort">Powersort</h3>
<p>Method 2—or, indeed <em>Method 2’,</em> a slight modification of the
bisection rule—is the basis for <em>powersort</em>.</p>

<p>This method is much more similar to <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a>
than to standard mergesort:
it proceeds in one pass from left to right over the input,
and detects the next run in the input.
For each new run, we may decide to do some merges now, or we delay them and
keep the runs on a to-do-stack.</p>

<p>While Timsort uses a rather complicated set of rules to decide what and when to merge,
powersort assigns each adjacent pair of runs an easy to compute integer,
its <em>“power”</em> and upon arrival of a new pair,
simply executes all postponed merges of higher power.</p>

<p>Like peeksort, powersort provably adapts optimally to existing runs (up to linear terms),
something Timsort <a href="https://arxiv.org/abs/1801.04641">provably does <em>not</em></a>.</p>

	</div>
</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Sebastian Wild</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li><a href="http://orcid.org/0000-0002-6061-9177">ORCID: 0000-0002-6061-9177</a></li>
          <li><a href="https://scholar.google.de/citations?user=aMyZiK0AAAAJ">Google Scholar Profile</a></li>
          <li><a href="http://dblp.uni-trier.de/pers/hd/w/Wild:Sebastian">DBLP Publication List</a></li>
          <li><a href="http://arxiv.org/a/wild_s_2">arXiv Author ID</a></li>

          <p>  </p>
          <li><a href="https://www.liverpool.ac.uk/computer-science/staff/sebastian-wild">Profile at UofL</a></li>
          <li><a href="http://wwwagak.cs.uni-kl.de/home/staff/sebastian-wild">(Old) website TU KL</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          <li><a href="mailto:%73%65%62%61%77%69%6C%64@%67%6D%61%69%6C.%63%6F%6D" title="Contact me">sebawild at gmail</a> ⋅
            <a href="http://pgp.mit.edu:11371/pks/lookup?op=get&amp;search=0x38600ABC14973198">PGP</a></li>
          <li><a href="mailto:%77%69%6C%64@%6C%69%76.%61%63.%75%6B" title="Contact me">wild at liv.ac.uk</a> ⋅
            <a href="http://pgp.mit.edu:11371/pks/lookup?op=get&amp;search=0x34EE39A78B149255">PGP</a></li>

              <p>  </p>
          <li><del><a href="mailto:%77%69%6C%64@%75%77%61%74%65%72%6C%6F%6F.%63%61" title="Contact me">wild at uwaterloo.ca</a></del> ⋅
            <a href="http://pgp.mit.edu:11371/pks/lookup?op=get&amp;search=0x34EE39A78B149255">PGP</a></li>
          <li><del><a href="mailto:%77%69%6C%64@%63%73.%75%6E%69-%6B%6C.%64%65" title="Contact me">wild at cs.uni-kl.de</a></del></li>

          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Quick links:</p>
        <ul style="margin-top: -1.5ex;">
          <li><a href="/publications">my publications</a></li>
          <li><a href="https://disk.wild-inter.net:5001/fbsharing/J0v0S8yF">my library</a></li>
        </ul>
      </div>
    </div>
  </div>
</footer>


  </body>

</html>
