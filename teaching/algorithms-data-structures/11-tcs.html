<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Lektion 11: Berechenbarkeit &amp; P vs. NP</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/fonts/pagella/stylesheet.css" type="text/css" charset="utf-8" />
  <link rel="stylesheet" href="/fonts/epigrafica/stylesheet.css" type="text/css" charset="utf-8" />
  <link rel="stylesheet" href="/fonts/fontawesome/fontawesome-all.min.css" type="text/css" charset="utf-8" />
  <link rel="stylesheet" href="/fonts/academicons/academicons.min.css" type="text/css" charset="utf-8" />
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://www.wild-inter.net/teaching/algorithms-data-structures/11-tcs">
  <link rel="alternate" type="application/rss+xml" title="Sebastian Wild's Site" href="https://www.wild-inter.net/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Sebastian</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#46433A" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#46433A" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#46433A" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/research/">Research</a>
          
        
          
          <a class="page-link" href="/teaching/">Teaching</a>
          
        
          
          <a class="page-link" href="/posts/">Blog</a>
          
        
          
          <a class="page-link" href="/about/">About</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <link rel="stylesheet" href="lessons.css">
<script src="lightweight-embed.js"></script>

<article class="post">
	<div class="post-back">
		<small>
			<p><a href="/teaching/algorithms-data-structures/#flipped-lectures">⬑ Liste aller flipped lectures.</a>
			&nbsp;&mdash;&nbsp; Algorithmen und Datenstrukturen</p>
		</small>
	</div>

	<h1 class="post-title"><p>Lektion 11: Berechenbarkeit &amp; P vs. NP</p>
</h1>

	<div class="page-content">
		<img src="lesson-11.svg" class="float-right"/>

<p>
	Diese Lektion bietet eine kurze Einführung in die größten
	Errungenschaften der theoretischen Informatik:
	das Abstecken der Grenzen der prinzipiellen Berechenbarkeit und
	der Polynomial-Zeit-Berechenbarkeit.
	Letzteres bringt uns auch zu einer der grundlegendsten und bedeutendsten
	offenen Fragen unserer Zeit: P = NP?
</p>
<p>
	Auf dem Weg dort hin werdet ihr lernen, Computer und Berechnungen
	aus einem völlig neuen Blickwinkel zu betrachten:
	Was ist die minimale Fähigkeit, die eine Maschine haben muss,
	um die prinzipiellen Möglichkeiten moderner Computer zu erreichen?
	Es zeigt sich, dass ein äußerst primitives mathematische Modell,
	die <em>Turing-Maschine,</em>
	schon die gleiche Mächtigkeit wie jeder physikalisch denkbare Computer
	zu haben scheint.
</p>
<p>
	Anhand dieses einfachen Modells werdet ihr lernen, dass es
	Probleme gibt, auf die Computer mathematisch beweisbar keine Antwort
	liefern können.
</p>
<p>
	Unter den prinzipiell lösbaren Problemen gibt es eine Vielzahl,
	für die nur unbrauchbar langsame Algorithmen bekannt sind,
	genauer: es ist kein Algorithmus bekannt, dessen worst-case Laufzeit
	eine polynomielle order of growth hat, der also für ein festes k
	in O(n<sup>k</sup>) arbeitet.
	Ob es solche Algorithmen gibt
	(und sie nur noch keiner, trotz intensiver Bemühungen, gefunden hat)
	oder nicht, ist ein offenes Problem, das als Frage »P = NP?« abgekürzt wird.
	Es gibt aber die Theorie der NP-Vollständigkeit, die genaue Aussagen
	zulässt, wie hoffnungslos die Suche nach solchen schnellen Algorithmen
	für gewisse Probleme ist.
</p>
<p>
	Auch wenn die Aussagen in dieser Lektion sehr abstrakt bleiben,
	haben sie direkte Konsequenzen für praktische Anwendungen;
	insbesondere lohnt es sich zu lernen zu erkennen,
	wann einem jemand eine (beweisbar oder höchstwahrscheinlich)
	unmögliche Aufgabe anbefiehlt.
</p>

<h3>Lernziele</h3>
<ul>
	<li>Ein Beispiel für ein nicht berechenbares Problem kennen,</li>
	<li>in einfachen Fällen nachweisen können, dass ein Problem nicht berechenbar ist,</li>
	<li>die Frage hinter »P=NP?« anschaulich beschreiben können,</li>
	<li>Evidenz liefern für die Vermutung P≠NP,</li>
	<li>in einfachen Fällen nachweisen können, dass ein Problem NP-vollständig ist,</li>
	<li>Lösungsansätze anwenden können, um in der Praxis mit NP-vollständigen
		Problemen umzugehen.</li>
</ul>




<h3>Fragensammlung für die Q&amp;A Session</h3>
<p>
	Tragt hier Fragen ein, die während der Vorbereitung aufkamen,
	und die ihr gerne klären möchtet.
	Bewertet außerdem die existierenden Fragen.
</p>
<p>
	<iframe src="https://piratenpad.de/p/ADS-fragen-tcs?showControls=true&showChat=false&showLineNumbers=true&useMonospaceFont=false" class="piratenpad"></iframe>
</p>
<!--
<p>
	<iframe src="https://kavula.fachschaft.informatik.uni-kl.de/p/text?showControls=true&showChat=false&showLineNumbers=true&useMonospaceFont=false" class="piratenpad"></iframe>
</p>
<iframe src="https://goo.gl/dK7bfJ"></iframe>
-->
<details>
<summary>
	<strong>Hausordnung</strong>
</summary>
<small>
<ul>
    <li>Es ist explizit erlaubt/erwünscht, Fragen aus den
		<em>Aufgaben zur Vorbereitung</em> unter den Videos
		zu übernehmen, wenn ihr diese der Q&amp;A Session besprechen wollt.</li>
	<li>Auch wenn ihr gerade keine eigene Frage stellen möchtet,
		sind die Fragen der anderen oft hilfreiche Denkanstöße auch für euch.
		Deshalb, und um Fragen für die Q&amp;A Sessions zu priorisieren,
		könnt ihr Fragen <b>bewerten</b>.
		<br/>
		Tragt dazu bei einer Frage entweder ein (zusätzliches) »+« ein,
		wenn ihr diese Frage interessant findet, oder ein (zusätzliches) »-«,
		wenn ihr sie nicht hilfreich findet (z.B. weil die Antwort direkt im
		Video gegeben wird).
		Listet zur besseren Übersicht zuerst alle »+«, dann alle »-«, jeweils in 5er Gruppen.
		</li>
    <li>Bevor ihr eine neue Frage eintragt, schaut ob eine existierende Frage
		eurer sehr nahe kommt;
		wenn ja, schreibt eure Frage als alternative Formulierung zu dieser Frage dazu.</li>
    <li>Wenn ihr der Meinung seid, ihr könnt eine Frage in wenigen Worten beantworten,
		so ergänzt eure Antwort unterhalb der Frage.
		Auch diese Antworten könnt ihr bewerten, wenn ihr sie hilfreich findet,
		oder Erwiderungen ergänzen, wenn ihr sie für falsch haltet.
	</li>
    <li>Seid konstruktiv.</li>
</ul>
</small>
</details>


<h2>Material</h2>

<p>
	<a href="#teil1">Teil 1</a>,
	<a href="#teil2">Teil 2</a>,
	<a href="#teil3">Teil 3</a>,
	<span class="small"><a href=#optional>optionale Themen</a>.</span>
</p>

<p>
	Die Videos entstammen der Princeton Vorlesung <em>Introduction to Computer Science</em>
	von Robert Sedgewick und Kevin Wayne.
<p/>
<p>
	Die  Videos wurden von Kevin Wayne exklusiv für A&amp;DS zur
	Verfügung gestellt und sind deshalb nur mit Passwort abrufbar.
	Da es dieses Feature bei Youtube nicht gibt, sind sie bei vimeo gehostet;
	dort gibt es leider die beschleunigte Wiedergabe nicht.
	Im HTML5-Video Player kann man sie aber über Browser-Plugins nachrüsten:
	<a href="https://addons.mozilla.org/en-US/firefox/addon/vplaybackspeed/?src=api">Firefox</a>,
	<a href="https://chrome.google.com/webstore/detail/vimeo-repeat-speed/noonakfaafcdaagngpjehilgegefdima">Chrome</a>.
	Leider funktionieren diese widerum nur in der vollen Ansicht, nicht für die
	eingebetten Player auf dieser Seite.
</p>
<p>
	Das Passwort für die Videos erhaltet ihr im Kurs.
</p>

<!--<div class="youtube"><div class="youtube-player" data-id="g8DejJF9THI" data-opts="start=100&amp;end=105"></div></div>-->

<h2 id="teil1">Teil 1 &ndash; Motivation und Denkweisen der theoretischen Informatik</h2>
<p>
	Diese Lektion ist in ihren Aussagen weit abstrakter als die vorhergehenden,
	daher gibt Teil 1 einen Überblick über die Ziele der theoretischen Informatik.
</p>

<h3>1.1 &ndash; Introduction to Theoretical Computer Science</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/196737338" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	In diesem Video gibt Sedgewick einen Überblick über die Philosophie und Ziele
	der theoretischen Informatik (theoretical computer science, TCS).
	Ein herausragendes Merkmal der Informatik ist es, dass viele Ergebnisse
	der theoretischen Forschung direkte Verwendung in der Praxis finden;
	Sedgewick gibt Beispiele, die diese Behauptung untermauern.
</p>
	Im letzten Teil des Videos gibt Sedgewick einen Ausblick auf einen
	Teil von TCS (REs and DFAs), den wir in A&amp;DS nicht behandeln,
	der aber einen guten Einstieg in die Denkweise von TCS ermöglicht.
</p>
<p class="small">
	Wenn du schon immer wissen wolltest, was reguläre Ausdrücke sind, und wie man
	damit arbeitet, findest du die ausgelassenen Videos im <a href="#optional">optionalen Teil</a>.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Was sind laut Sedgewick die fundamentalen Fragen in TCS?</li>
	<li>Was versteht man unter <em>abstract maschines?</em></li>
	<li>Welche Anwendungen von TCS-Ergebnissen nennt Sedgewick?</li>
</ol>

<h3>1.2 &ndash; Context on Formal Systems</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/197493156" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	Dieses Video liefert eine kurze Historie der Theorie von Beweisbarkeit
	und Logik.
	Ein <a href="https://en.wikipedia.org/wiki/Formal_system">formales System</a>
	(formal system) ist in diesem Zusammenhang
	eine Menge von logischen Regeln, die es erlaubt durch stures Verwenden
	von (»typographischen«) Regeln Aussagen zu beweisen.
	Die Frage der Berechenbarkeit,
	um die es uns in dieser Lektion geht,
	ist aus diesem Kontext hervorgegangen.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche beiden »Unvollständigkeit« der Mathematik nennt Sedgewick?</li>
</ol>

<h2 id="teil2">Teil 2 &ndash; Grenzen der Berechenbarkeit</h2>
<p>
	In Teil 2 werden wir die allgemeine Frage thematisieren,
	was ein Computer eigentlich ist und was er nicht ist,
	um dann den Beweis zu führen, dass es für unsere Computer
	prinzipielle Grenzen gibt:
	Wir werden Beispiele von Problemen kennen lernen, die sich definitiv nicht
	im Allgemeinen automatisch lösen lassen.
</p>


<h3>2.1 &ndash; Turing Machines</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/197493315" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	Dieses Video beschreibt die Turing-Maschinen (Turing machine, TM)
	als ein denkbar einfachstes Modell für Computer und Berechnungen.
	Neben der Definition gibt Sedgewick mehrere Beispiele
	und erklärt, wie man eine TM in Java simulieren kann.<br/>
	Sedgewick erwähnt mehrfach DFAs (deterministic finite automata);
	diese Verweise dürft ihr ignorieren.
</p>
<p class="small">
	Es mag den Verständnis dienlich sein, sich dennoch das Video zu
	endlichen Automaten (DFAs) im
	<a href="#optional">optionalen Teil</a> anzusehen,
	da DFAs eine vereinfachte Vorstufe zu Turing Maschinen darstellen.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Aus welchen »Bestandteilen« ist eine TM aufgebaut?</li>
	<li>Wie arbeitet eine TM? Beschreibe einen »Schritt« der Maschine.</li>
</ol>


<h3>2.2 &ndash; Universality</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/197493956" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	Die vielleicht größte Errungenschaft heutiger Computer überhaupt ist,
	dass man mit einem einzigen Gerät, derselben universellen Hardware,
	<em>alle möglichen</em>
	Aufgaben erledigen kann; insbesondere auch solche, die zum Zeitpunkt
	der Konstruktion dieses Computers noch gar nicht erfunden waren!
	Voraussetzung dafür ist, dass man einen Computer »zur Laufzeit«
	programmieren kann;
	eine Eigenschaft, die man sich wissentlich vor Augen führen muss,
	weil sie uns so ganz und gar selbstverständlich geworden ist.
</p>
<p>
	Dieses Video skizziert, wie man ein solches universelles Verhalten
	in den primitiven Turing-Maschinen erreichen kann.
	Die Bedeutung dieser Möglichkeit, der Existenz universeller TM,
	ist weitreichend, denn sie führt zum zentralen Begriff der
	<em>Simulation</em> eines Berechnungsmodells mithilfe eines anderen
	Berechnungsmodells:
	Es genügt jetzt, die eine universelle TM in einem anderen Modell zu simulieren,
	um zu beweisen, dass <em>alle</em> denkbaren TM simuliert werden können.
</p>
<p>
	Auf diese Weise kam man zu dem verblüffenden Ergebnis, dass
	<em>alle</em> bisher erdachten Berechnungsmodelle sich gegenseitig simulieren
	können, und somit <em>alle</em> gleich ausdrucksstark sind.
</p>
<p>
	Der Abschnitt über Conway's Game of Life ist nicht Klausur-relevant.
	(Die Animationen fand ich aber zu hübsch um sie zu entfernen.)
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Beschreibe (grob) die vorgestellte Text-Kodierung einer TM.</li>
	<li>Welche (groben) Schritte muss eine universelle TM leisten,
		um eine ihr auf dem Eingabeband gegebene TM zu simulieren?</li>
	<li>Was besagt die These von Church und Turing?</li>
</ol>

<h3>2.3 &ndash; Computability</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/198694930" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	In diesem Video beschreibt Sedgewick zwei bewiesenermaßen nicht-berechenbare
	Probleme:
	Das Post'sche Korrespondenzproblem (Post's correspondence problem, PCP)
	und das Halteproblem (halting problem).
	Für letzteres gibt Sedgewick den berühmten anschaulichen Beweis der
	Nicht-Berechenbarkeit, der auf dem
	<a href="https://de.wikipedia.org/wiki/Paradoxon_des_Epimenides">Paradoxon des Epimenides</a>
	(dem Lügner-Paradox) beruht.
</p>
<p>
	Beide Probleme haben als Ausgabe lediglich ein Ja oder Nein;
	das ist typische für TCS-Betrachtungen.
	Man nennt solche Probleme Entscheidungsprobleme und sagt sie sind
	<em>unentscheidbar (undecidable)</em>, wenn sie nicht berechenbar sind.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Beschreibe anschaulich die Eingabe und Fragestellung des PCP.</li>
	<li>Beschreibe anschaulich die Eingabe und Fragestellung des Halteproblems.</li>
	<li>Was ist das Lügner-Paradoxon?</li>
	<li>Sedgewick verwendet im Beweis der Nicht-Berechenbarkeit eine Method
		<tt>boolean halt(String f, String x)</tt>.
		Welche Bedeutung haben dabei <tt>f</tt> und <tt>x</tt>?
		Was soll der Rückgabewert von <tt>halt</tt> sein?
		Sei präzise!</li>
	<li>Wie argumentiert Sedgewick, dass es diese Method <tt>halt</tt> nicht geben kann?</li>
</ol>

<h3>2.4 &ndash; Implications</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/198695173" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	In diesem Video diskutiert Sedgewick, welche Schlussfolgerungen aus
	der Existenz nicht berechenbarer Probleme zu ziehen sind,
	und listet ein Menge weitere solcher Probleme.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche weiteren unentscheidbaren Probleme nennt Sedgewick?
		Wähle zwei Probleme aus und beschriebe im Detail,
		was die Eingabe und Fragestellung ist.</li>
</ol>




<h2 id="teil3">Teil 3 &ndash; NP-Vollständigkeit und Komplexitätstheorie</h2>
<p>
	In diesem Teil beziehen wir neben der prinzipiellen Lösbarkeit wieder
	die Laufzeit mit ein und kommen schließlich zur großen Frage P=NP?
</p>


<h3>3.1 &ndash; Intractability</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/198695406" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	In diesem Video gibt Sedgewick die grundlegenden Definitionen
	für diesen Teil:
	Polynomialzeit (poly-time),
	effiziente Algorithmen (efficient algorithms),
	effizient lösbare Probleme (tractable problems).
	Zuerst aber gibt er einen Abriss der Historie und motiviert anhand
	eines Beispiels (dem Traveling Salesperson Problem, TSP),
	dass prinzipielle Berechenbarkeit alleine in diesem Universum wenig wert ist.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Was ist die Eingabe und Ausgabe beim TSP?</li>
	<li>Was ist ein »UBERcomputer«?</li>
	<li>Welche Eingabegröße für TSP könnte ein UBERcomputer per brute-force lösen?</li>
	<li>Wann hat ein Algorithmus »polynomielle Laufzeit«?</li>
	<li>Wann nennen wir (in dieser Lektion) einen Algorithmus effizient? Sei präzise.</li>
	<li>Wann ist ein Problem <em>intractable</em> (nicht effizient lösbar)?</li>
	<li>Welche vier allgemeinen mathematischen Probleme definiert Sedgewick?
		Welche davon sind tractable (nach aktuellem Wissensstand)?</li>
</ol>


<h3>3.2 &ndash; P and NP</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/198695863" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	In diesem Video definiert Sedgewick die Komplexitätsklassen P und NP
	als Klassen von Suchproblemen inklusive einer Reihe von Beispielen.
	Anschließend stellt er P=NP Frage und diskutiert ihre
	direkten und weiterführenden Konsequenzen.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Was ist ein Suchproblem (search problem)? Was ist ein Verifizierer? Was ist NP?</li>
	<li>Welche Beispiele für NP-Probleme nennt Sedgewick?
		Beschreibe für eines davon was Eingabe, Fragestellung und Suchraum sind,
		und wie ein Verifizierer für das Problem funktioniert.</li>
	<li>Was ist P? Was ist der Unterschied zu NP?</li>
	<li>Welche übertragenen Konsequenzen von P=NP bzw. P≠NP nennt Sedgewick?</li>
</ol>

<h3>3.3 &ndash; Poly-time Reductions</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/198696181" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	In diesem Video beschreibt Sedgewick den Begriff der Polynomialzeit-Reduktion
	(poly-time reduction)
	von Problemen, und wie man damit die Nicht-Effizient-Lösbarkeit eines Problems
	auf ein neues übertragen kann.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche Arbeitshypothese nimmt Sedgewick zu Beginn an?</li>
	<li>Was bedeutet es, ein Problem X auf ein Problem Y polyzeit-zu-reduzieren (X→Y)? Sei präzise.</li>
	<li>Was bedeutet die Aussage, Polyzeit-Reduktionen sind transitiv?</li>
	<li>Welche zwei Ziele kann man laut Sedgewick mittels Reduktionen erreichen?</li>
	<li>Wie reduziert Sedgewick SAT auf ILP? (Und was waren SAT und ILP gleich wieder?)</li>
	<li>Welche weiteren Probleme nennt Sedgewick auf die SAT sich reduzieren lässt?</li>
</ol>

<h3>3.4 &ndash; NP-Completeness</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/199122959" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	Mit den Polyzeit-Reduktionen haben wir alle Zutaten zusammen um
	den wichtigen Begriff der NP-Vollständigkeit zu definieren:
	auf ein NP-vollständiges Problem lassen sich <em>alle</em> Probleme aus NP
	polyzeit-reduzieren.
	Das bedeutet sofort, dass mit einem Polyzeit-Algorithmus für ein einziges NP-vollständiges
	Problem implizit auch ein Polyzeit-Algorithmus für <em>jedes</em> NP-Problem vorliegt.
	Dieser Umstand ist der Grund, warum man davon ausgehen kann, dass ein NP-vollständiges
	Problem wohl keine effiziente Lösung haben dürfte:
	Schließlich versuchen sich schon seit Jahrzehnten viele Forscher weltweit daran,
	für all die NP-Probleme einen effizienten Algorithmus zu finden, ohne dass
	es bisher auch nur für eines gelungen wäre.
</p>
<p>
	Um diese Argumentation anzuwenden, muss man aber erst einmal die NP-Vollständigkeit
	eines Problems nachweisen, was am einfachsten gelingt, indem man ein neues
	Problem auf ein schon bekanntermaßen NP-vollständiges polyzeit-reduziert.
	Dazu braucht man wiederum ein ersten NP-vollständiges Problem.
	Sedgewick skizziert deshalb den Nachweis der NP-Vollständigkeit der Mutter
	aller NP-vollständigen Probleme: SAT.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Wann ist ein Problem NP-vollständig? Sei präzise.</li>
	<li>Skizziere ganz grob wie Sedgewick begründet, dass SAT NP-vollständig ist.</li>
	<li>Was bedeutet das für die Liste von Problemen aus Video 3.3,
		also die Probleme auf die sich SAT polyzeit-reduzieren lässt?</li>
</ol>

<h3>3.5 &ndash; Living with Intractability</h3>
<div><iframe class="youtube" src="https://player.vimeo.com/video/199123289" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
<p>
	Nachdem wir gesehen haben, dass man für viele Probleme keinen effizienten Algorithmus
	erwarten darf, stellt Sedgewick in diesem Video die Frage, wie damit (in der Praxis)
	umzugehen ist.
	Neben einigen allgemeinen Ideen, wie man trotz NP-Vollständigkeit ein Problem
	anpacken kann, zeigt Sedgewick auch Beispiele aus der Kryptographie,
	wo man sich die Komplexität einiger Probleme zu Nutzen macht.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche Gründe kann es haben, dass sich einige NP-vollständige Probleme
		(z.B. SAT, TSP, ILP) in der Praxis doch schnell (genug) lösen lassen,
		(und das auch noch ohne UBERcomputer)?</li>
	<li>Die Komplexität welches Problems macht sich die Kryptographie zu Nutze?</li>
</ol>






<div class="small" style="padding-top:10ex;">
	<h2 id="optional">Optionale Themen</h2>
	<p>
		Hier sind einige Videos mit weiterführenden Inhalten und hübschen Anwendungen
		gesammelt.
		<strong>Diese sind <em>nicht</em> Teil
			(des Klausur-relevanten Stoffes von) von A&amp;DS.</strong>
		Sie sind hier gesammelt, weil
		in den Videos oben teilweise Bezug auf diese Themen genommen wird,
		und ich Interessierten die Videos nicht vorenthalten möchte.
	</p>

	<h3>Regular Expressions</h3>
	<div><iframe class="youtube" src="https://player.vimeo.com/video/196737398" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
	<p>
		Reguläre Ausdrücke (regular expressions, REs) sind eine flexible und äußerst
		praktische Möglichkeit ein Muster für Strings anzugeben.
		Dieses Video definiert REs und gibt konkrete Beispiele.
	</p>

	<h3>Deterministic Finite Automata</h3>
	<div><iframe class="youtube" src="https://player.vimeo.com/video/196737456" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
	<p>
		Deterministische endliche Automaten (deterministic finite automata, DFAs)
		sind sehr eingeschränktes Modell eines Computers, der
		nach einfachen Regeln einen Eingabetext akzeptieren oder ablehnen kann.
		Das Video stellt DFAs vor, zeigt wie sie in Java simuliert werden
		können und diskutiert das erstaunliche Resultat, dass es zu jedem
		regulären Ausdruck einen äquivalenten DFA gibt, und umgekehrt.
		Die beiden so unterschiedlichen Mechanismen sind also genau gleich mächtig.
	</p>

	<h3>Applications of REs and DFAs</h3>
	<div><iframe class="youtube" src="https://player.vimeo.com/video/200329956" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
	<p>
		Dieses Video skizziert, wie man mittels REs und DFAs
		nach flexiblen Mustern in Texten suchen kann,
		und welche Implementierungen die Java library dafür mitbringt.
	</p>

	<h3>Limitations of REs</h3>
	<div><iframe class="youtube" src="https://player.vimeo.com/video/197492817" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>
	<p>
		Obwohl reguläre Ausdrücke in vielen Anwendungen helfen,
		hat ihre Ausdrucksstärke auch Grenzen.
		Diese werden in diesem Video aufgezeigt, und
		dienen als Motivation und Ausgangspunkt für mächtigere Maschinenmodelle
		wie die Turingmaschinen.
	</p>


</div>

	</div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Sebastian Wild</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <p>Contact:</p>
        <ul class="social-media-list">
          <li><a href="mailto:%73%65%62%61%77%69%6C%64@%67%6D%61%69%6C.%63%6F%6D" title="Contact me">sebawild at gmail</a> ⋅
            <a href="http://pgp.mit.edu/pks/lookup?op=get&search=0x38600ABC14973198">PGP</a></li>
            <li><a href="mailto:%77%69%6C%64@%69%6E%66%6F%72%6D%61%74%69%6B.%75%6E%69-%6D%61%72%62%75%72%67.%64%65" title="Contact me">wild at informatik.uni-marburg.de</a>
              <!-- ⋅ <a href="http://pgp.mit.edu/pks/lookup?op=get&search=0x34EE39A78B149255">PGP</a> --></li>
          <li><a href="mailto:%77%69%6C%64@%6C%69%76%65%72%70%6F%6F%6C.%61%63.%75%6B" title="Contact me">wild at liverpool.ac.uk</a> ⋅
            <a href="http://pgp.mit.edu/pks/lookup?op=get&search=0x34EE39A78B149255">PGP</a></li>

              <p>  </p>
          <li><del><a href="mailto:%77%69%6C%64@%75%77%61%74%65%72%6C%6F%6F.%63%61" title="Contact me">wild at uwaterloo.ca</a></del> ⋅
            <a href="http://pgp.mit.edu/pks/lookup?op=get&search=0x34EE39A78B149255">PGP</a></li>
          <li><del><a href="mailto:%77%69%6C%64@%63%73.%75%6E%69-%6B%6C.%64%65" title="Contact me">wild at cs.uni-kl.de</a></del></li>
          <p>  </p>
          <li><a href="https://www.uni-marburg.de/de/staff-info?dn=pdgd3qt7ea">Website at UMR</a></li>
          <li><a href="https://www.liverpool.ac.uk/computer-science/staff/sebastian-wild">Website at UoL</a></li>
          <li><a href="https://www.csc.liv.ac.uk/~swild">intranet site at UoL</a></li>
          <li><a href="https://tcs.csc.liv.ac.uk">TCS @ Liverpool</a></li>
          <li><a href="http://wwwagak.cs.uni-kl.de/home/staff/sebastian-wild">(Old) website TU KL</a></li>

          

          
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <p>Elsewhere:</p>
        <ul class="contact-list">
          <li><a href="https://github.com/sebawild" title="GitHub sebawild"><i class="fab fa-github"></i> GitHub sebawild</a></li>
          <li><a href="https://www.linkedin.com/in/sebastian-wild-liverpool/"><i class="fab fa-linkedin"></i> LinkedIn profile</a></li>
          <li><a rel="me" href="https://mathstodon.xyz/@wild" title="Mastodon @wild@mathstodon.xyz" ><i class="fab fa-mastodon"></i> @wild@mathstodon.xyz</a></li>
          <li><del><a href="https://twitter.com/Sebastian_Wild_" title="Twitter @Sebastian_Wild_"><i class="fab fa-twitter"></i> @Sebastian_Wild_</a></del></li>
          <li><a href="https://bsky.app/profile/sebastianwild.bsky.social" title="Bluesky @sebastianwild.bsky.social">🦋 @sebastianwild</a></li>
          
          <p>  </p>
          <li><a href="http://orcid.org/0000-0002-6061-9177" title="ORCID: 0000-0002-6061-9177"><i class="ai ai-orcid"></i> 0000-0002-6061-9177</a></li>
          <li><a href="https://scholar.google.de/citations?user=aMyZiK0AAAAJ"><i class="ai ai-google-scholar"></i>
 Google Scholar profile</a></li>
          <li><a href="http://dblp.uni-trier.de/pers/hd/w/Wild:Sebastian"><i class="ai ai-dblp"></i> DBLP publication list</a></li>
          <li><a href="https://www.semanticscholar.org/author/3124206"><i class="ai ai-semantic-scholar"></i> Semantic Scholar Author Page</a></li>
          <li><a href="http://arxiv.org/a/wild_s_2"><i class="ai ai-arxiv"></i> arXiv Author ID</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Quick links:</p>
        <ul style="margin-top: -1.5ex;">
          <li><a href="/publications">my publications</a></li>
          <li><a href="https://disk.wild-inter.net:5001/fbsharing/J0v0S8yF">my library</a></li>
        </ul>
      </div>
    </div>
  </div>
</footer>


  </body>

</html>
