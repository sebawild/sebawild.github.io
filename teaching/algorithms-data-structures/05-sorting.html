<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Lektion 5: Sortieren</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/fonts/pagella/stylesheet.css" type="text/css" charset="utf-8" />
  <link rel="stylesheet" href="/fonts/epigrafica/stylesheet.css" type="text/css" charset="utf-8" />
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://wild-inter.net/teaching/algorithms-data-structures/05-sorting">
  <link rel="alternate" type="application/rss+xml" title="Sebastian Wild's Site" href="https://wild-inter.net/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Sebastian</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#46433A" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#46433A" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#46433A" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/research">Research</a>
          
        
          
          <a class="page-link" href="/teaching/">Teaching</a>
          
        
          
          <a class="page-link" href="/posts/">Blog</a>
          
        
          
          <a class="page-link" href="/about">About</a>
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <link rel="stylesheet" href="lessons.css">
<script src="lightweight-embed.js"></script>

<article class="post">
	<div class="post-back">
		<small>
			<p><a href="/teaching/algorithms-data-structures/#flipped-lectures">⬑ Liste aller flipped lectures.</a>
			&nbsp;&mdash;&nbsp; Algorithmen und Datenstrukturen</p>
		</small>
	</div>

	<h1 class="post-title"><p>Lektion 5: Sortieren</p>
</h1>

	<div class="page-content">
      <div class="wrapper">
        <img src="lesson-05.svg" class="float-right"/>

<p>
	In dieser Lektion behandeln wir Algorithmen zum Sortieren einer Liste von Elementen.
</p>
<p>
	Sortieren ist das vielleicht wichtigste Problem der Informatik mit
	vielfältigsten Anwendungen; eine Liste zuerst zu sortieren vereinfacht
	in vielen Fällen die weitere Verarbeitung.
	Aus den vielen Anwendungen ergeben sich eine Vielzahl von Anforderungsprofilen
	and gute Sortieralgorithmen, die kein Verfahren allein erfüllen kann;
	daher ist es wertvoll, die Vor- und Nachteile der verschiedenen
	Sortieralgorithmen zu verstehen.
</p>
<p>
	Darüber hinaus lassen sich einige verwandte Probleme
	(z.B. zufälliges Permutieren und das Finden des Medians einer Menge)
	durch leicht abgewandelte Sortierverfahren lösen.
	Die Prinzipien der Algorithmen sind also über das Sortieren hinaus
	hilfreich.
</p>

<h3>Lernziele</h3>
<ul>
	<li>Funktionsweise und Charakteristika bekannter Sortieralgorithmen kennen</li>
	<li>auf Basis dieser ein geeignetes Sortierverfahren für eine Anwendung
		wählen können</li>
	<li>Priority Queues einsetzen können</li>
	<li>Denkweisen erlernen, um geforderte Performancecharakteristika als
		unmöglich zu entlarven (»untere Schranken«)</li>
</ul>




<h3>Fragensammlung für die Q&amp;A Session</h3>
<p>
	Tragt hier Fragen ein, die während der Vorbereitung aufkamen,
	und die ihr gerne klären möchtet.
	Bewertet außerdem die existierenden Fragen.
</p>
<p>
	<iframe src="https://piratenpad.de/p/ADS-fragen-sorting?showControls=true&showChat=false&showLineNumbers=true&useMonospaceFont=false" class="piratenpad"></iframe>
</p>
<!--
<p>
	<iframe src="https://kavula.fachschaft.informatik.uni-kl.de/p/text?showControls=true&showChat=false&showLineNumbers=true&useMonospaceFont=false" class="piratenpad"></iframe>
</p>
<iframe src="https://goo.gl/dK7bfJ"></iframe>
-->
<details>
<summary>
	<strong>Hausordnung</strong>
</summary>
<small>
<ul>
    <li>Es ist explizit erlaubt/erwünscht, Fragen aus den
		<em>Aufgaben zur Vorbereitung</em> unter den Videos
		zu übernehmen, wenn ihr diese der Q&amp;A Session besprechen wollt.</li>
	<li>Auch wenn ihr gerade keine eigene Frage stellen möchtet,
		sind die Fragen der anderen oft hilfreiche Denkanstöße auch für euch.
		Deshalb, und um Fragen für die Q&amp;A Sessions zu priorisieren,
		könnt ihr Fragen <b>bewerten</b>.
		<br/>
		Tragt dazu bei einer Frage entweder ein (zusätzliches) »+« ein,
		wenn ihr diese Frage interessant findet, oder ein (zusätzliches) »-«,
		wenn ihr sie nicht hilfreich findet (z.B. weil die Antwort direkt im
		Video gegeben wird).
		Listet zur besseren Übersicht zuerst alle »+«, dann alle »-«, jeweils in 5er Gruppen.
		</li>
    <li>Bevor ihr eine neue Frage eintragt, schaut ob eine existierende Frage
		eurer sehr nahe kommt;
		wenn ja, schreibt eure Frage als alternative Formulierung zu dieser Frage dazu.</li>
    <li>Wenn ihr der Meinung seid, ihr könnt eine Frage in wenigen Worten beantworten,
		so ergänzt eure Antwort unterhalb der Frage.
		Auch diese Antworten könnt ihr bewerten, wenn ihr sie hilfreich findet,
		oder Erwiderungen ergänzen, wenn ihr sie für falsch haltet.
	</li>
    <li>Seid konstruktiv.</li>
</ul>
</small>
</details>


<h2>Material</h2>

<p>
	Zu dieser Lektion gehören recht viele Videos (viele davon sind recht kurz).
	Der Übersichtlichkeit halber
	sind sie in 4 Teile aufgeteilt:
	<br />
	<a href="#teil1">Teil 1</a>,
	<a href="#teil2">Teil 2</a>,
	<a href="#teil3">Teil 3</a>,
	<a href="#teil4">Teil 4</a>,
	<span class="small"><a href=#optional>optionale Themen</a>.</span>
</p>

<p>
	Die Videos entstammen dem Coursera MOOC
	<em>Algorithms Part I</em>
	von Robert Sedgewick und Kevin Wayne.
<p/>

<h2 id="teil1">Teil 1 &ndash; Einführung und Elementare Verfahren</h2>

<p>
	Die erste Reihe von Videos beschreibt einfache, intuitive Verfahren
	zum Sortieren und verwandte Probleme.
</p>

<h3>1.1 &ndash; Sorting Introduction</h3>
<div class="youtube"><div class="youtube-player" data-id="GENxxQx9Erg"></div></div>
<p>
	Dieses Video beschreibt, was wir unter dem Problem »Sortieren« genau verstehen.
	Dabei wird Java's `Comparable`-Abstraktion eingeführt, die generische
	Sortiermethoden ermöglicht.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche Methoden hat `Comparable`?
		Wie sieht eine Implementierung dieser Methoden aus
		(für eine Beispielklasse deiner Wahl)?</li>
	<li>Welche Abstraktion führt Sedgewick darüber hinaus für seinen Code ein?</li>
	<li>Müssen die zu sortierenden Elemente in einem Array vorliegen?</li>
</ol>

<h3>1.2 &ndash; Selection Sort</h3>
<div class="youtube"><div class="youtube-player" data-id="0nNqHW1eFUQ"></div></div>
<p>
	Dieses Video beschreibt Sortieren durch wiederholtes Suchen des Minimums.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche Invariante erhält Selectionsort?</li>
	<li>Wie viele Vergleiche und Swaps braucht Selectionsort?</li>
	<li>Welche Eigenschaften der Eingabe beeinflussen die Kosten?</li>
</ol>

<h3>1.3 &ndash; Insertion Sort</h3>
<div class="youtube"><div class="youtube-player" data-id="ou6MimDWZ7w"></div></div>
<p>
	Dieses Video beschreibt Sortieren durch Einfügen, den »Kartenspieleralgorithmus«.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche Invariante erhält Insertionsort?</li>
	<li>Wie viele Vergleiche und Swaps braucht Insertionsort?</li>
	<li>Welche Eigenschaften der Eingabe beeinflussen die Kosten?</li>
	<li>Was sind <em>Inversionen</em>?</li>
</ol>

<h3>1.4 &ndash; Shuffling</h3>
<div class="youtube"><div class="youtube-player" data-id="fglX4Cf-sFg"></div></div>
<p>
	Eine Liste zufällig zu permutieren, sodass alle möglichen Reihenfolgen
	der Elemente gleich wahrscheinlich sind, ist ein typischer Baustein	in
	<a href="https://en.wikipedia.org/wiki/Monte_Carlo_method">
		(Monte-Carlo) Simulationen
	</a>
	&ndash; und leicht falsch zu machen!
	Dieses Video zeigt, wie es richtig geht.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche zwei Verfahren zum <em>random shuffling</em> werden vorgestellt?</li>
	<li>Wie effizient sind sie?</li>
	<li>Alle solche Verfahren müssen auf Zufallszahlen zugreifen können.
		Welche Arten von Zufallszahlen werden in den vorgestellten Verfahren
		verwendet?</li>
</ol>



<h2 id="teil2">Teil 2 &ndash; Mergesort und Theorie</h2>
<p>
	Dieser Teil behandelt Mergesort, die informationstheoretische untere Schranke
	fürs Sortieren, sowie zwei Aspekte, die beim Sortieren von Objekten wichtig sind:
	selbst-definierte Ordnungsrelationen und Stabilität von Sortierverfahren.
</p>

<h3>2.1 &ndash; Mergesort</h3>
<div class="youtube"><div class="youtube-player" data-id="ypae0cmi7hM"></div></div>
<p>
	Dieses Video stellt Mergesort vor, neben Quicksort (s.u.) das wichtigste
	Verfahren in der Praxis.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Was versteht man unter <em>merging</em>?
		Beschreibe die Idee anhand zweier Stapel von Papierdokumenten
		(sagen wir Rechnungen, die nach Datum sortiert werden).
		Welche Voraussetzungen muss die Eingabe erfüllen,
		und was gilt dann nach dem merge?</li>
	<li>Wie wird aus merge der Mergesort?</li>
	<li>Wie könnte man Mergesort statt als rekursive Methode
		mit einem <tt>Stack</tt> implementieren?</li>
	<li>Wie viele Vergleiche verwendet Mergesort?
		Vergleiche die Anzahl für N=1000 mit der für Selectionsort.</li>
	<li>Wie kann man diese Vergleichsanzahl mathematisch beweisen?
		Skizziere die verwendeten Methoden.</li>
	<li>Welche Optimierungen von Mergesort schlägt Sedgewick vor?</li>
</ol>


<h3>2.2 &ndash; Sorting Complexity</h3>
<div class="youtube"><div class="youtube-player" data-id="iK6HLS6SN2Q"></div></div>
<p>
	In diesem Video wird bewiesen, dass eine gewisse Mindestanzahl von Vergleichen
	nötig sein muss, um korrekt sortieren zu können.
</p>
<p>
	Das Argument selbst ist nicht besonders trickreich, liefert aber doch
	eine nicht-triviale Aussage: Es ist im Allgemeinen nicht möglich,
	mit einer fixen Anzahl von Durchläufen über eine Liste zu sortieren.
	Solche Aussagen bezeichnet man als untere Schranken (lower bounds)
	eines Problems (hier des Sortierens).
	Die Möglichkeit, solche starken, allgemeingültigen Unmöglichkeitsaussagen
	mathematisch zu beweisen, grenzt die <span style="font-size:70%">(theoretische)</span>
	Informatik
	klar von den Ingenieurswissenschaften ab, wo i.d.R. eine große Lücke
	zwischen Stand der Technik und harten physikalischen Grenzen verbleibt
	(z.B. Wirkungsgrad von Verbrennungsmotoren vs. Perpetuum Mobile)
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Was sind <em>decision trees?</em></li>
	<li>Was ist das <em>decision tree model?</em></li>
	<li>
		Was ist die <em>präzise</em> Aussage der
		informationstheoretischen unteren Schranke?
		<ul>
			<li>Für welche Algorithmen gilt die Aussage?</li>
			<li>Für welche Eingabegröße N gilt die Aussage?</li>
			<li>Für welche Eingaben einer gegebenen Größe N gilt die Aussage?</li>
			<li>Welches Kostenmodell wird betrachtet? (Was heißt das für die Laufzeit?)</li>
		</ul>
	</li>
	<li>Was bedeutet das für Mergesort?</li>
</ol>

<h3>2.3 &ndash; Comparators</h3>
<div class="youtube"><div class="youtube-player" data-id="Dpq1Mt1DS4w"></div></div>
<p>
	Dieses Video beschreibt die <tt>Comparator</tt> API in Java.
</p>
<p><small>
	<strong>Hinweis:</strong>
	Das Beispiel am Ende (polar order, slide 47-48) bezieht sich auf eine
	Anwendungen des Sortierens (Berechnen von convex hulls mittels Graham scan),
	die wir hier nicht behandeln.
	Das Beispiel könnt ihr also ignorieren.)
</small></p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche Methoden hat das Interface <tt>Comparator</tt>?</li>
	<li>Was sind Vorteile gegenüber dem Implementieren von <tt>Comparable</tt>?</li>
</ol>

<h3>2.4 &ndash; Stability</h3>
<div class="youtube"><div class="youtube-player" data-id="YGawSKpwHbw"></div></div>
<p>
	In diesem Video wird erklärt, was es heißt,
	dass ein Sortierverfahren <em>stabil</em> ist,
	und welche unserer Algorithmen diese Eigenschaft haben.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Was ist Stabilität?</li>
	<li>Für welche Anwendungen ist ein stabiles Sortierverfahren nötig?
		Gib ein Beispiel.</li>
	<li>Welche uns bekannten Verfahren sind stabil?</li>
	<li>Demonstriere an einem stabilen Algorithmus deiner Wahl,
		dass man Stabilität leicht einbüßen kann,
		wenn man Details im Code (unachtsam) ändert.</li>
</ol>


<h2 id="teil3">Teil 3 &ndash; Quicksort und Praxis</h2>

<p>
	Teil 3 der Sortierlektion behandelt Quicksort, die schnellste Methode in der Praxis.
</p>


<h3>3.1 &ndash; Quicksort</h3>
<div class="youtube"><div class="youtube-player" data-id="1a-chpO4bgQ"></div></div>
<p>
	Dieses Video stellt Quicksort vor.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Was versteht man unter <em>partitioning</em>?
		Beschreibe die Idee anhand eines Stapels von
		Rechnungen mit Datum und eines Stichtages.
		Welche Voraussetzungen muss die Eingabe erfüllen,
		und was gilt dann nach dem partitioning?</li>
	<li>Wie wird aus partitioning der Quicksort?</li>
	<li>Wie könnte man Quicksort statt als rekursive Methode
		mit einem <tt>Stack</tt> implementieren?</li>
	<li>Inwiefern hat Quicksorts Struktur Ähnlichkeit mit Mergesort? Was ist anders?</li>
	<li>Wie viele Vergleiche verwendet der randomisierte Quicksort
		<ul>
			<li>minimal,</li>
			<li>maximal,</li>
			<li>in Erwartung?</li>
		</ul>
	</li>
	<li>Wie kann man die erwartete Vergleichsanzahl mathematisch beweisen?
		Skizziere die verwendeten Methoden.</li>
	<li>Welche Optimierungen von Mergesort schlägt Sedgewick vor?</li>
</ol>


<h3>3.2 &ndash; Duplicate Keys</h3>
<div class="youtube"><div class="youtube-player" data-id="w-pHijluxMM"></div></div>
<p>
	Dieses Video thematisiert den Effekt, den Elemente mit gleichem Schlüssel
	auf die Performance von Sortieralgorithmen haben.
	Es wird eine verallgemeinerte untere Schranke präsentiert,
	die mit 3-way Quicksort (fat-pivot Quicksort) in der Praxis erreicht werden
	kann.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Wann sind zwei Elemente gleich bzgl. <tt>compareTo</tt> in Java?</li>
	<li>In welchen Anwendungen ist mit vielen solchen Duplikaten zu rechnen?</li>
	<li>Welchen Einfluss haben Duplikate auf die Anzahl Vergleiche in
		<ul>
			<li>Mergesort und</li>
			<li>Quicksort (so wie bei Sedgewick implementiert)?</li>
		</ul>
	</li>
	<li>Was ist die Idee bei <em>3-way partitioning?</em>
		Wie sieht die Invariante aus?</li>
	<li>Was besagt die untere Schranke für Multimengen?</li>
	<li>Nimm an, wir sortieren eine Liste mit 500 Frauen und Männern
		nach Geschlecht
		(♂ &lt; ♀ und vereinfachend gebe es hier nur männlich und weiblich);
		wie viele Vergleiche sind dazu mindestens nötig?
		Mach eine Überschlagsrechnung!
		Wie viele Vergleiche würde Mergesort in etwa benötigen?
	</li>
	<li>Was ist über die Anzahl Vergleiche von 3-way Quicksort bekannt?</li>
</ol>

<h3>3.3 &ndash; System Sorts</h3>
<div class="youtube"><div class="youtube-player" data-id="QV2zF17KgB4"></div></div>
<p>
	In diesem Video beschreibt Sedgewick die Sortiermethoden der Java Library
	und was für solche industrial-strength Implementierungen zu beachten ist.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche API stellt Java zum Sortieren bereit?</li>
	<li>Welche Eigenschaften von Sortierverfahren können in Anwendungen
		eine Rolle spielen?</li>
</ol>



<h2 id="teil4">Teil 4 &ndash; Priority Queues und Heapsort</h2>
<p>
	In Teil 4 fügen wir unserer Liste von abstrakten Datentypen die Priority Queue
	hinzu, die in diversen Anwendungen und für spätere Algorithmen hilfreich ist.
	Auf Priority Queues basiert auch Heapsort, unser erster Sortieralgorithmus, der
	linearithmische Worst-Case Laufzeit garantiert und
	dabei ohne zusätzlichen Speicherplatz auskommt.
	Auch wenn Heapsort in der Praxis eine untergeordnete Rolle spielt,
	ist er Perle und Meilenstein der Algorithmik.
</p>

<h3>4.1 &ndash; Priority Queue API</h3>
<div class="youtube"><div class="youtube-player" data-id="L8fNRwqR60o"></div></div>
<p>
	Dieses Video definiert die API von Priority Queues und
	nennt einige ihrer Anwendungen.
	Es werden außerdem primitive Implementierungen der API vorgestellt,
	die aber den Laufzeitanforderungen der Anwendungen nicht gerecht werden.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche Operationen bieten <tt>MaxPQ</tt> bzw. <tt>MinPQ</tt></li>
	<li>Warum verwendet der topM test client eine <tt><em>Min</em>PQ</tt>
		um die M <em>größten</em> <tt>Transaction</tt>s zu finden &ndash;
		ist das ein Fehler?</li>
	<li>Welche elementaren Implementierungen werden vorgestellt?
		Welche Laufzeiten (order of growth) haben dann die PQ Operationen?</li>
</ol>


<h3>4.2 &ndash; Binary Heaps</h3>
<div class="youtube"><div class="youtube-player" data-id="Dzmq297giJ0"></div></div>
<p>
	In diesem Video wird die Datenstruktur <em>binary heap</em> präsentiert,
	mit der sich eine effiziente Priority Queue konstruieren lässt.
</p>
<p class="small">
	<strong>Hinweis:</strong> Die in manchen Anwendungen von PQs zusätzlich verwendeten
	Methoden, die erlauben, die Priorität von schon in der Queue befindlichen Elementen
	zu modifizieren, werden hier (noch) nicht besprochen.
</p>
<p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Was ist ein <em>binary tree</em> (Binärbaum) nach der Definition aus dem Video?
		Seid präzise und gebt Beispiele.</li>
	<li>Was ist ein <em>vollständiger</em> Binärbaum?
		Wie viele topologisch verschiedene (d.h. ohne Labels der Knoten zu berücksichtigen)
		vollständige Binärbäume mit N Knoten gibt es?</li>
	<li>Wann ist ein Binärbaum <em>heap-ordered?</em>
		Was bedeutet das für den Schlüssel in der Wurzel?</li>
	<li>Wie repräsentiert Sedgewick einen vollständigen Binärbaum als Array?
		Warum geht das, ohne explizit zu speichern,
		wo die Kinder eines Knotens gespeichert sind?</li>
	<li>Was tut die <em>swim</em> Operation im binary heap?
		Welche Bedingungen verlangt swim zu Beginn (Vorbedingungen, preconditions),
		und was ist nach Beendigung von swim sichergestellt (Nachbedingungen, postconditions)?</li>
	<li>Was tut <em>sink?</em> Was sind die Vor- und Nachbedingungen?</li>
	<li>Wie funktioniert <em>insert</em> für binary-heap MaxPQs?</li>
	<li>Wie funktioniert <em>delMax</em> für binary-heap MaxPQs?</li>
	<li>Welche Laufzeit (order of growth) haben die Operationen?</li>
	<li>Was ist <em>immutability?</em>
		Was kann schiefgehen, wenn die Keys einer PQ nicht immutable sind?</li>
</ol>




<div class="small">

<h2 id="optional" style="padding-top:10ex;">Optionale Themen</h2>
<p>
	Hier sind einige Videos mit weiterführenden Inhalten und hübschen Anwendungen
	gesammelt.
	<strong>Diese sind <em>nicht</em> Teil
		(des Klausur-relevanten Stoffes von) von A&amp;DS.</strong>
	Sie sind hier gesammelt, weil
	in den Videos oben teilweise Bezug auf diese Themen genommen wird,
	und ich Interessierten die Videos nicht vorenthalten möchte.
</p>



<h3>Shell Sort (optional)</h3>
<div class="youtube"><div class="youtube-player" data-id="NNiqkVgxaXs"></div></div>
<p>
	Dieses Video beschreibt Shellsort, einen Exoten unter den Sortierverfahren
	mit eigenen Qualitäten.
</p>
<!-- <p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Welche Invariante erhält Shellsort?</li>
	<li>Was ist über die Anzahl Vergleiche und Swaps für Shellsort bekannt?</li>
	<li>Welche besonderen Vorteile hat Shellsort?</li>
</ol> -->


<h3>Bottom-up Mergesort (optional)</h3>
<div class="youtube"><div class="youtube-player" data-id="WVl2QSe4R14"></div></div>
<p>
	In diesem Video wird eine Variante von Mergesort vorgestellt,
	die ganz auf Rekursion (oder explizite Stacks) verzichtet.
</p>
<!-- <p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Wie geht bottom-up Mergesort vor?</li>
	<li>Ergibt sich bei bottom-up und top-down (dem »normalen« Mergesort)
		die gleichen Aufteilungen in Teilarrays?</li>
</ol>
 -->

<h3>Selection (optional)</h3>
<div class="youtube"><div class="youtube-player" data-id="dNuPJQPt0Ps"></div></div>
<p>
	In diesem Video beschreibt Sedgewick das <em>(order-statistic) selection problem</em>
	und Quickselect, eine Abwandlung von Quicksort, die das Problem löst.
	Die Existenz von Linearzeit-Algorithmen für das Problem wird erwähnt.
</p>
<!-- <p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Was sind Eingaben und Ausgaben für selection?</li>
	<li>Welche beiden Lösungen des Problems werden erklärt?</li>
	<li>Wie arbeitet Quickselect? Warum funktioniert das?</li>
	<li>Sedgewicks Quickselect ist keine rekursive Prozedur;
		warum braucht man hier keine Rekursion?</li>
	<li>Was ist die Anzahl Vergleiche von Quickselect?
		<ul>
			<li>minimal,</li>
			<li>maximal,</li>
			<li>in Erwartung?</li>
		</ul>
	</li>
	<li>Gibt es Algorithmen für Selection mit linearer Laufzeit im <em>worst case?</em></li>
</ol> -->

<h3>Heapsort (optional)</h3>
<div class="youtube"><div class="youtube-player" data-id="lfHUpPGEgAM"></div></div>
<p>
	In diesem Video wird heapsort erklärt und analysiert.
	Heapsort konstruiert eine PQ direkt im zu sortierenden Array
	und schafft es damit als erster Algorithmus mit nur konstant viel
	Zusatzspeicher und worst-case linearithmischer Vergleiche-Zahl zu sortieren.
</p>
<!-- <p>Aufgaben zur Vorbereitung:</p>
<ol>
	<li>Wie kann man (auf ganz konzeptionellem Level) mit einer PQ sortieren?</li>
	<li>Welchen Vorteil von Heapsort würde eine solche Verwendung der
		PQ als Blackbox verspielen?</li>
	<li>Wie arbeitet Sedgewicks Heapsort?</li>
	<li>Wie viele Vergleiche und Swaps benötigt Heapsort?</li>
	<li>Wie viel zusätzlichen Speicher (order of growth) benötigt (Sedgewicks) Heapsort?</li>
</ol> -->


<h3>Anwendungen (optional)</h3>

<p>
	In zwei weiteren Videos werden hübsche Anwendungen aus der Praxis vorgestellt:
	Die Berechnung der konvexen Hülle einer Menge von Punkten,
	sowie eine Event-basierte Simulation von kollidierenden Partikeln,
	die Einsichten in physikalische Effekte bietet.
	Auf den ersten Blick scheint keines dieser Anwendungen etwas
	mit Sortieren zu tun zu haben;
	ihre effiziente Lösung basiert aber auf den Methoden dieser Lektion.
</p>

<div class="youtube"><div class="youtube-player" data-id="Ctsbm6an1CU"></div></div>
<div class="youtube"><div class="youtube-player" data-id="gO_VkLIJCmw"></div></div>

</div>

      </div>
    </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Sebastian Wild</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
				<a href="mailto:sebawild@gmail.com" title="Contact me">sebawild at gmail</a>,
				<a href="http://pgp.mit.edu:11371/pks/lookup?op=get&search=0x38600ABC14973198">PGP Key</a>
			</li>
			<li>
				<a href="mailto:wild@uwaterloo.ca" title="Contact me">wild at uwaterloo.ca</a>,
				<a href="http://pgp.mit.edu:11371/pks/lookup?op=get&search=0x34EE39A78B149255">PGP Key</a>
          <li>
				<del><a href="mailto:wild@cs.uni-kl.de" title="Contact me">wild at cs.uni-kl.de</a></del>
          </li>
          <li><a href="http://wwwagak.cs.uni-kl.de/home/staff/sebastian-wild">Website at TU KL</a></li>
          <li><a href="http://orcid.org/0000-0002-6061-9177">ORCID ID: 0000-0002-6061-9177</a></li>
          <li><a href="https://scholar.google.de/citations?user=aMyZiK0AAAAJ">Google Scholar Profile</a></li>
		  <li><a href="http://dblp.uni-trier.de/pers/hd/w/Wild:Sebastian">DBLP Publication List</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>
			Website of <a href=/about>Sebastian Wild</a>.

        </p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
